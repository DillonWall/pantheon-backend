package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"net/url"
	"pantheon-auth/graph/model"
	"pantheon-auth/pkg/auth"

	"golang.org/x/crypto/bcrypt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.UserData) (*model.AuthResponse, error) {
	// todo: validation
	user, err := r.UserRepo.GetUser_byUsername(input.Username)
	if user != nil {
		return nil, fmt.Errorf("Username already taken")
	}

	err = r.UserRepo.CreateUser(input.Username, input.Password)
	if err != nil {
		return nil, err
	}

	tokenString, err := auth.GenerateToken(input.Username)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: &tokenString,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.UserData) (*model.AuthResponse, error) {
	// todo: validation
	user, err := r.UserRepo.GetUser_byUsername(input.Username)
	if err != nil {
		return nil, err
	}

	// Hash the password from the request and compare it with the stored password
	err = bcrypt.CompareHashAndPassword(
		[]byte(user.Passwordhash),
		[]byte(input.Password),
	)
	if err != nil {
		return nil, fmt.Errorf("Invalid username or password: %w", err)
	}

	tokenString, err := auth.GenerateToken(input.Username)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: &tokenString,
	}, nil
}

// Verify is the resolver for the verify field.
func (r *mutationResolver) Verify(ctx context.Context, token string) (bool, error) {
	return auth.ValidateToken(token, r.UserRepo)
}

// SearchImages is the resolver for the searchImages field.
func (r *queryResolver) SearchImages(ctx context.Context, token string, query string) ([]*model.Image, error) {
	valid, err := auth.ValidateToken(token, r.UserRepo)
	if !valid || err != nil {
		return nil, err
	}

	query = url.QueryEscape(query)

	// todo: make concurrent
	// Aggregate results from multiple APIs
	var allImages []*model.Image
	for _, api := range r.ImageAPIs {
		image, err := api.SearchSingleImage(ctx, query)
		if err != nil {
			log.Printf("Error querying %T: %v", api, err)
			continue // Skip this API but keep others
		}
		allImages = append(allImages, image)
	}

	if len(allImages) == 0 {
		return nil, fmt.Errorf("no images found for query: %s", query)
	}

	return allImages, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
